/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 * @format
 */

'use strict';

import type {
  Nullable,
  SchemaType,
  NativeModulePropertySchema,
  NativeModuleMethodParamSchema,
  NativeModuleReturnTypeAnnotation,
  NativeModuleFunctionTypeAnnotation,
  NativeModuleParamTypeAnnotation,
} from '../../CodegenSchema';

import type { AliasResolver } from './Utils';
const { createAliasResolver, getModules } = require('./Utils');
const { unwrapNullable } = require('../../parsers/flow/modules/utils');

type FilesOutput = Map<string, string>;

const FileTemplate = ({
  packageName,
  className,
  methods,
  imports,
}: $ReadOnly< {|
  packageName: string,
    className: string,
      methods: string,
        imports: string,
|}>) => {
  return `
/**
 * ${'C'}opyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the LICENSE file in the root
 * directory of this source tree.
 *
 * ${'@'}generated by codegen project: GenerateModuleKotlinSpec.js
 *
 * @nolint
 */

package ${packageName};

${imports}

public abstract class ${className}(reactContext:ReactApplicationContext?) : ReactContextBaseJavaModule(reactContext!!), ReactModuleWithSpec, TurboModule {
${methods}
}
`;
};

function translateFunctionParamToKotlinType(
  param: NativeModuleMethodParamSchema,
  createErrorMessage: (typeName: string) => string,
  resolveAlias: AliasResolver,
  imports: Set<string>,
): string {
  const { optional, typeAnnotation: nullableTypeAnnotation } = param;
  const [
    typeAnnotation,
    nullable,
  ] = unwrapNullable<NativeModuleParamTypeAnnotation>(nullableTypeAnnotation);
  const isRequired = !optional && !nullable;

  function wrapIntoNullableIfNeeded(generatedType: string) {
    if (!isRequired) {
      return `${generatedType}?`;
    }
    return generatedType;
  }

  let realTypeAnnotation = typeAnnotation;
  if (realTypeAnnotation.type === 'TypeAliasTypeAnnotation') {
    realTypeAnnotation = resolveAlias(realTypeAnnotation.name);
  }

  switch (realTypeAnnotation.type) {
    case 'ReservedFunctionValueTypeAnnotation':
      switch (realTypeAnnotation.name) {
        case 'RootTag':
          return !isRequired ? 'Double?' : 'Double';
        default:
          (realTypeAnnotation.name: empty);
          throw new Error(createErrorMessage(realTypeAnnotation.name));
      }
    case 'StringTypeAnnotation':
      return wrapIntoNullableIfNeeded('String');
    case 'NumberTypeAnnotation':
      return !isRequired ? 'Double?' : 'Double';
    case 'FloatTypeAnnotation':
      return !isRequired ? 'Double?' : 'Double';
    case 'DoubleTypeAnnotation':
      return !isRequired ? 'Double?' : 'Double';
    case 'Int32TypeAnnotation':
      return !isRequired ? 'Double?' : 'Double';
    case 'BooleanTypeAnnotation':
      return !isRequired ? 'Boolean?' : 'Boolean';
    case 'ObjectTypeAnnotation':
      imports.add('com.facebook.react.bridge.ReadableMap');
      if (typeAnnotation.type === 'TypeAliasTypeAnnotation') {
        // No class alias for args, so it still falls under ReadableMap.
        return !isRequired ? 'ReadableMap?' : 'ReadableMap';
      }
      return !isRequired ? 'ReadableMap?' : 'ReadableMap';
    case 'GenericObjectTypeAnnotation':
      // Treat this the same as ObjectTypeAnnotation for now.
      imports.add('com.facebook.react.bridge.ReadableMap');
      return !isRequired ? 'ReadableMap?' : 'ReadableMap';
    case 'ArrayTypeAnnotation':
      imports.add('com.facebook.react.bridge.ReadableArray');
      return !isRequired ? 'ReadableMap?' : 'ReadableMap';
    case 'FunctionTypeAnnotation':
      imports.add('com.facebook.react.bridge.Callback');
      return !isRequired ? 'Callback?' : 'Callback';
    default:
      (realTypeAnnotation.type: empty);
      throw new Error(createErrorMessage(realTypeAnnotation.type));
  }
}

function translateFunctionReturnTypeToKotlinType(
  nullableReturnTypeAnnotation: Nullable<NativeModuleReturnTypeAnnotation>,
  createErrorMessage: (typeName: string) => string,
  resolveAlias: AliasResolver,
  imports: Set<string>,
): string {
  const [
    returnTypeAnnotation,
    nullable,
  ] = unwrapNullable<NativeModuleReturnTypeAnnotation>(
    nullableReturnTypeAnnotation,
  );

  function wrapIntoNullableIfNeeded(generatedType: string) {
    if (nullable) {
      return `${generatedType}?`;
    }
    return generatedType;
  }

  let realTypeAnnotation = returnTypeAnnotation;
  if (realTypeAnnotation.type === 'TypeAliasTypeAnnotation') {
    realTypeAnnotation = resolveAlias(realTypeAnnotation.name);
  }

  switch (realTypeAnnotation.type) {
    case 'ReservedFunctionValueTypeAnnotation':
      switch (realTypeAnnotation.name) {
        case 'RootTag':
          return nullable ? 'Double?' : 'Double';
        default:
          (realTypeAnnotation.name: empty);
          throw new Error(createErrorMessage(realTypeAnnotation.name));
      }
    case 'VoidTypeAnnotation':
      return '';
    case 'PromiseTypeAnnotation':
      return '';
    case 'StringTypeAnnotation':
      return wrapIntoNullableIfNeeded('String');
    case 'NumberTypeAnnotation':
      return nullable ? 'Double?' : 'Double';
    case 'FloatTypeAnnotation':
      return nullable ? 'Double?' : 'Double';
    case 'DoubleTypeAnnotation':
      return nullable ? 'Double?' : 'Double';
    case 'Int32TypeAnnotation':
      return nullable ? 'Double?' : 'Double';
    case 'BooleanTypeAnnotation':
      return nullable ? 'Boolean?' : 'Boolean';
    case 'ObjectTypeAnnotation':
      imports.add('com.facebook.react.bridge.WritableMap');
      return nullable ? 'WritableMap?' : 'WritableMap';
    case 'GenericObjectTypeAnnotation':
      imports.add('com.facebook.react.bridge.WritableMap');
      return nullable ? 'WritableMap?' : 'WritableMap';
    case 'ArrayTypeAnnotation':
      imports.add('com.facebook.react.bridge.WritableArray');
      return nullable ? 'WritableMap?' : 'WritableMap';
    default:
      (realTypeAnnotation.type: empty);
      throw new Error(createErrorMessage(realTypeAnnotation.type));
  }
}

// Build special-cased runtime check for getConstants().
function buildGetConstantsMethod(
  method: NativeModulePropertySchema,
  imports: Set<string>,
): string {
  const [
    methodTypeAnnotation,
  ] = unwrapNullable<NativeModuleFunctionTypeAnnotation>(method.typeAnnotation);
  if (
    methodTypeAnnotation.returnTypeAnnotation.type === 'ObjectTypeAnnotation'
  ) {
    const requiredProps = [];
    const optionalProps = [];
    const rawProperties =
      methodTypeAnnotation.returnTypeAnnotation.properties || [];
    rawProperties.forEach(p => {
      if (p.optional || p.typeAnnotation.type === 'NullableTypeAnnotation') {
        optionalProps.push(p.name);
      } else {
        requiredProps.push(p.name);
      }
    });
    if (requiredProps.length === 0 && optionalProps.length === 0) {
      // Nothing to validate during runtime.
      return '';
    }

    imports.add('com.facebook.react.common.build.ReactBuildConfig');

    const requiredPropsFragment =
      requiredProps.length > 0
        ? `listOf(
          ${requiredProps
          .sort()
          .map(p => `"${p}"`)
          .join(',\n          ')}
      )`
        : '';
    const optionalPropsFragment =
      optionalProps.length > 0
        ? `listOf(
          ${optionalProps
          .sort()
          .map(p => `"${p}"`)
          .join(',\n          ')}
      )`
        : '';

    return `  protected abstract fun getTypedExportedConstants(): Map<String, Any>;

  override fun getConstants():Map<String, Any>{
    val constants = getTypedExportedConstants();
    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
      val obligatoryFlowConstants =  HashSet<String>(${requiredPropsFragment})
      val optionalFlowConstants =  HashSet<String>(${optionalPropsFragment})
      var undeclaredConstants =  HashSet<String>(constants.keys);
      undeclaredConstants.removeAll(obligatoryFlowConstants);
      undeclaredConstants.removeAll(optionalFlowConstants);
      if (undeclaredConstants.isNotEmpty()) {
        throw IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
      }
      undeclaredConstants = obligatoryFlowConstants;
      undeclaredConstants.removeAll(constants.keys);
      if (undeclaredConstants.isNotEmpty()) {
        throw IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
      }
    }
    return constants
  }`;
  }

  return '';
}

module.exports = {
  generate(
    libraryName: string,
    schema: SchemaType,
    moduleSpecName: string,
    packageName?: string,
  ): FilesOutput {
    const files = new Map();
    const normalizedPackageName =
      packageName != null ? packageName : 'com.facebook.fbreact.specs';
    const outputDir = `kotlin/${normalizedPackageName.replace(/\./g, '/')}`;
    const nativeModules = getModules(schema);

    Object.keys(nativeModules).forEach(hasteModuleName => {
      const {
        aliases,
        excludedPlatforms,
        spec: { properties },
      } = nativeModules[hasteModuleName];
      if (excludedPlatforms != null && excludedPlatforms.includes('android')) {
        return;
      }
      const resolveAlias = createAliasResolver(aliases);
      const className = `${hasteModuleName}Spec`;

      const imports: Set<string> = new Set([
        // Always required.
        'com.facebook.react.bridge.ReactApplicationContext',
        'com.facebook.react.bridge.ReactContextBaseJavaModule',
        'com.facebook.react.bridge.ReactMethod',
        'com.facebook.react.bridge.ReactModuleWithSpec',
        'com.facebook.react.turbomodule.core.interfaces.TurboModule',
      ]);

      const methods = properties.map(method => {
        if (method.name === 'getConstants') {
          return buildGetConstantsMethod(method, imports);
        }

        const [
          methodTypeAnnotation,
        ] = unwrapNullable<NativeModuleFunctionTypeAnnotation>(
          method.typeAnnotation,
        );

        // Handle return type
        const translatedReturnType = translateFunctionReturnTypeToKotlinType(
          methodTypeAnnotation.returnTypeAnnotation,
          typeName =>
            `Unsupported return type for method ${method.name}. Found: ${typeName}`,
          resolveAlias,
          imports,
        );
        const returningPromise =
          methodTypeAnnotation.returnTypeAnnotation.type ===
          'PromiseTypeAnnotation';
        const isSyncMethod =
          methodTypeAnnotation.returnTypeAnnotation.type !==
          'VoidTypeAnnotation' && !returningPromise;

        // Handle method args
        const traversedArgs = methodTypeAnnotation.params.map(param => {
          const translatedParam = translateFunctionParamToKotlinType(
            param,
            typeName =>
              `Unsupported type for param "${param.name}" in ${method.name}. Found: ${typeName}`,
            resolveAlias,
            imports,
          );
          return `${param.name}: ${translatedParam}`;
        });

        if (returningPromise) {
          // Promise return type requires an extra arg at the end.
          imports.add('com.facebook.react.bridge.Promise');
          traversedArgs.push('promise: Promise');
        }
        const methodKotlinAnnotation = `@ReactMethod${isSyncMethod ? '(isBlockingSynchronousMethod = true)' : ''
          }`;
        return `  ${methodKotlinAnnotation}
  public abstract fun ${method.name}(${traversedArgs.join(
          ', ',
        )})${translatedReturnType === "" ? "" : ":"}${translatedReturnType};`;
      });

      files.set(
        `${outputDir}/${className}.kt`,
        FileTemplate({
          packageName: normalizedPackageName,
          className,
          methods: methods.filter(Boolean).join('\n\n'),
          imports: Array.from(imports)
            .sort()
            .map(p => `import ${p};`)
            .join('\n'),
        }),
      );
    });

    return files;
  },
};
