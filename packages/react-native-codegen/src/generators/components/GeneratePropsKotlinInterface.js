/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 * @format
 */

'use strict';

import type {
  CommandTypeShape,
  ComponentShape,
  PropTypeShape,
  SchemaType,
} from '../../CodegenSchema';
const {
  getImports,
  toSafeJavaString,
  getInterfaceJavaClassName,
} = require('./JavaHelpers');

// File path -> contents
type FilesOutput = Map<string, string>;

const template = `/**
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* ${'@'}generated by codegen project: GeneratePropsKotlinInterface.js
*/

package com.facebook.react.viewmanagers;

::_IMPORTS_::

public interface ::_CLASSNAME_::<T: ::_EXTEND_CLASSES_::> {
  ::_METHODS_::
}
`;


function getKotlinValueForProp(prop: PropTypeShape, imports): string {
  const typeAnnotation = prop.typeAnnotation;

  switch (typeAnnotation.type) {
    case 'BooleanTypeAnnotation':
      if (typeAnnotation.default === null) {
        return 'value: Boolean?';
      } else {
        return 'value: Boolean';
      }
    case 'StringTypeAnnotation':
      return 'value: String?';
    case 'Int32TypeAnnotation':
      return 'value: Int';
    case 'DoubleTypeAnnotation':
      return 'value: Double';
    case 'FloatTypeAnnotation':
      if (typeAnnotation.default === null) {
        return 'value: Float?';
      } else {
        return 'value: Float';
      }
    case 'ReservedPropTypeAnnotation':
      switch (typeAnnotation.name) {
        case 'ColorPrimitive':
          return 'value: Int?';
        case 'ImageSourcePrimitive':
          return 'value: ReadableMap?';
        case 'PointPrimitive':
          return 'value: ReadableMap?';
        case 'EdgeInsetsPrimitive':
          return 'value: ReadableMap?';
        default:
          (typeAnnotation.name: empty);
          throw new Error('Received unknown ReservedPropTypeAnnotation');
      }
    case 'ArrayTypeAnnotation': {
      return 'value: ReadableArray?';
    }
    case 'ObjectTypeAnnotation': {
      return 'value: ReadableMap?';
    }
    case 'StringEnumTypeAnnotation':
      return 'value: String';
    case 'Int32EnumTypeAnnotation':
      return 'value: Int?';
    default:
      (typeAnnotation: empty);
      throw new Error('Received invalid typeAnnotation');
  }
}

function generatePropsString(component: ComponentShape, imports) {
  if (component.props.length === 0) {
    return '// No props';
  }

  return component.props
    .map(prop => {
      return `fun set${toSafeJavaString(
        prop.name,
      )}(view: T, ${getKotlinValueForProp(prop, imports)});`;
    })
    .join('\n' + '  ');
}

function getCommandArgKotlinType(param) {
  const { typeAnnotation } = param;

  switch (typeAnnotation.type) {
    case 'ReservedFunctionValueTypeAnnotation':
      switch (typeAnnotation.name) {
        case 'RootTag':
          return 'Double';
        default:
          (typeAnnotation.name: empty);
          throw new Error(`Receieved invalid type: ${typeAnnotation.name}`);
      }
    case 'BooleanTypeAnnotation':
      return 'Boolean';
    case 'DoubleTypeAnnotation':
      return 'Double';
    case 'FloatTypeAnnotation':
      return 'Float';
    case 'Int32TypeAnnotation':
      return 'Int';
    case 'StringTypeAnnotation':
      return 'String';
    default:
      (typeAnnotation.type: empty);
      throw new Error('Receieved invalid typeAnnotation');
  }
}

function getCommandArguments(
  command: CommandTypeShape,
  componentName: string,
): string {
  return [
    'view: T',
    ...command.typeAnnotation.params.map(param => {
      const commandArgKotlinType = getCommandArgKotlinType(param);

      return `${commandArgKotlinType} ${param.name}`;
    }),
  ].join(', ');
}

function generateCommandsString(
  component: ComponentShape,
  componentName: string,
) {
  return component.commands
    .map(command => {
      const safeKotlinName = toSafeJavaString(command.name, false);

      return `fun ${safeKotlinName}(${getCommandArguments(
        command,
        componentName,
      )});`;
    })
    .join('\n' + '  ');
}

function getClassExtendString(component): string {
  const extendString = component.extendsProps
    .map(extendProps => {
      switch (extendProps.type) {
        case 'ReactNativeBuiltInType':
          switch (extendProps.knownTypeName) {
            case 'ReactNativeCoreViewProps':
              return 'View';
            default:
              (extendProps.knownTypeName: empty);
  throw new Error('Invalid knownTypeName');
}
        default:
(extendProps.type: empty);
throw new Error('Invalid extended type');
      }
    })
    .join('');

return extendString;
}

module.exports = {
  generate(
    libraryName: string,
    schema: SchemaType,
    moduleSpecName: string,
    packageName?: string,
  ): FilesOutput {
    const files = new Map();
    Object.keys(schema.modules).forEach(moduleName => {
      const module = schema.modules[moduleName];
      if (module.type !== 'Component') {
        return;
      }

      const { components } = module;

      // No components in this module
      if (components == null) {
        return;
      }

      return Object.keys(components)
        .filter(componentName => {
          const component = components[componentName];
          return !(
            component.excludedPlatforms &&
            component.excludedPlatforms.includes('android')
          );
        })
        .forEach(componentName => {
          const component = components[componentName];
          const className = getInterfaceJavaClassName(componentName);
          const fileName = `${className}.kt`;

          const imports = getImports(component, 'interface');
          const propsString = generatePropsString(component, imports);
          const commandsString = generateCommandsString(
            component,
            componentName,
          );
          const extendString = getClassExtendString(component);

          const replacedTemplate = template
            .replace(
              /::_IMPORTS_::/g,
              Array.from(imports)
                .sort()
                .join('\n'),
            )
            .replace(/::_CLASSNAME_::/g, className)
            .replace('::_EXTEND_CLASSES_::', extendString)
            .replace(
              '::_METHODS_::',
              [propsString, commandsString].join('\n' + '  ').trimRight(),
            )
            .replace('::_COMMAND_HANDLERS_::', commandsString);

          files.set(fileName, replacedTemplate);
        });
    });

    return files;
  },
};
